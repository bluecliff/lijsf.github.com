<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Blue Dream</title><link href="http://bluedream.me/" rel="alternate"></link><link href="http://bluedream.me/feeds/Linux.atom.xml" rel="self"></link><id>http://bluedream.me/</id><updated>2013-03-08T00:00:00+08:00</updated><entry><title>linux IO函数的效率(2)</title><link href="http://bluedream.me/linux-iohan-shu-de-xiao-lu-2.html" rel="alternate"></link><updated>2013-03-08T00:00:00+08:00</updated><author><name>lijsf</name></author><id>tag:bluedream.me,2013-03-08:linux-iohan-shu-de-xiao-lu-2.html</id><summary type="html">&lt;h1&gt;Ｃ标准IO库的效率&lt;/h1&gt;
&lt;p&gt;Ｃ标准IO库主要是stdio.h文件中所包含的函数。这些函数封装了系统内核级的调用
提供了一个标准的接口，根据标准接口，各个系统均可实现自己的IO库。所以在不同
系统上，有不同的具体优化策略，最终实现一个最优的IO效率。&lt;/p&gt;
&lt;p&gt;标准IO函数主要的优化策略是采用了缓冲机制。无论是读还是写，都是先读或者写到
一个系统缓冲区，该缓冲区由系统维护。直到缓冲区满或者必要时，才读写到具体的
文件。打开一个文件流，即建立一个和打开文件相对应的缓冲区。缓冲区大小与系统
相关。&lt;/p&gt;
&lt;p&gt;下面是标准IO函数的性能测试。&lt;/p&gt;
&lt;p&gt;从标准输入读100MB的文档，输出到标准输出。首先采用fgets和fputs函数，这两个函数
可以一次读入或者写指定大小的字符数到系统缓冲区。&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#define MAXLINE 1024&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;MAXLINE&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fgets&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;MAXLINE&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;stdin&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fputs&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;stdout&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="n"&gt;EOF&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;stdout error&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;测试该函数的执行时间:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="nb"&gt;time&lt;/span&gt; ./a.out &amp;lt;in&amp;gt;out
real    0m0.783s
user    0m0.204s
sys     0m0.168s
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其次，再用getc和putc实现上面的同样功能，这两个函数只能每一次读写一个字符进入缓冲区。&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;getc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stdin&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;EOF&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;putc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;stdout&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;EOF&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;error to put&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;同样测量该函数的执行时间：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="nb"&gt;time&lt;/span&gt; ./a.out &amp;lt;in&amp;gt;out
real    0m2.414s
user    0m1.800s
sys     0m0.200s
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;对比两个结果，可以看到，系统时间相差不大，这在于系统缓冲区大小是相同的，所以最终的系统
调用级的IO次数是相同的，这个和上一节中的采用最佳块大小时的IO时间是接近的，从侧面反映了
标准C的IO函数采用了优化过的缓冲区大小。&lt;/p&gt;
&lt;p&gt;两个函数执行时间相差比较大的是用户时间和实际时间，这主要是函数调用开销的影响。100MB的文件
一次读写一个字符和一次读写1024个字符，getc的调用次数是fgets的1024倍，这个开销反映在用户时间
的差距上。真实时间差距进一步拉大是因为进程等待的时间，函数调用次数越多，进程等待的可能性必然
也随之增大。&lt;/p&gt;</summary><category term="unix环境高级编程"></category><category term="linux编程"></category></entry><entry><title>linux IO函数的效率(1)</title><link href="http://bluedream.me/linux-iohan-shu-de-xiao-lu-1.html" rel="alternate"></link><updated>2013-03-06T00:00:00+08:00</updated><author><name>lijsf</name></author><id>tag:bluedream.me,2013-03-06:linux-iohan-shu-de-xiao-lu-1.html</id><summary type="html">&lt;p&gt;linux下iso-c实现即GNU的glibc库，IO库主要是头文件stdio.h文件下的一些函数。一般情况下应用到的
IO操作基本就是该库的IO函数的使用。但同时linux内核也提供了IO的系统调用。本文是在阅读Advanced
programming in the UNIX environment这本书时做的笔记，主要是关于ISO-C的IO库和linux系统调用IO的效率对比。&lt;/p&gt;
&lt;h2&gt;linux系统调用的IO&lt;/h2&gt;
&lt;p&gt;linux系统的文件IO大部分情况只需要用到5个函数：open,read,write,lseek和close。其他的还有一些
应用于原子操作以及文件共享等特殊应用的IO函数，如：dup,fcntl,sync,fsync和ioctl等函数。这些函
数都是linux/unix系统提供的系统调用，由内核完成。&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#include &amp;lt;fcntl.h&amp;gt;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;open&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;pathname&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;flag&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;...&lt;/span&gt;&lt;span class="cm"&gt;/* mode_t mode */&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;create&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;pathname&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;mode_t&lt;/span&gt; &lt;span class="n"&gt;mode&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="cp"&gt;#include &amp;lt;unistd.h&amp;gt;&lt;/span&gt;
&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;close&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;filedes&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="kt"&gt;off_t&lt;/span&gt; &lt;span class="nf"&gt;lseek&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;filedes&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;off_t&lt;/span&gt; &lt;span class="n"&gt;offset&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;whence&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="kt"&gt;ssize_t&lt;/span&gt; &lt;span class="nf"&gt;read&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;filedes&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;nbytes&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="kt"&gt;ssize_t&lt;/span&gt; &lt;span class="nf"&gt;write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;filedes&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;nbytes&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上面即几个常用IO函数的原型，顾名思义，也很容易理解其功能。主要有这些需要注意的：对于内核而言，
所有打开的文件都通过文件描述符引用，即一个证书，默认0,1,2分别对应标准输入，标准输出，标准出错。
文件的打开模式有多种，并且是否打开成功于进程有效id,进程的实际id都有关，同时也与文件的stat有关。&lt;/p&gt;
&lt;p&gt;系统调用级的IO函数都是不带缓冲的IO,write和read函数都把数据放在一个buf中写入磁盘，或者从磁盘读进
buf,该buf大小的选取对IO效率有很大的影响。最高效的选取应当是一个文件系统的block的大小，在linux的
ext4文件系统上，该数值是4096，所以理论上将是选取4096会得到一个高效的IO传输。&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#include &amp;lt;unistd.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;stdio.h&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;#define BUFFSIZE 8192&lt;/span&gt;

&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;argc&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[])&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;bsize&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;atoi&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;argv&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;BUFFSIZE&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;read&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;STDIN_FILENO&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;bsize&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;STDOUT_FILENO&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;write error&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;n&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;read erro&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上述程序完成对系统调用read和write效率的测试，实际上是从标准输入复制数据到标准输出。可选
的参数决定每次IO的buf的大小。使用time工具可以获取程序执行的时间。测试的数据in文件是100Ｍ
的一个英文文本文件。&lt;/p&gt;
&lt;p&gt;首先选择buf的大小为1,即每次只读写1个字节。&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;lijsf@echolii-PC:chapt3&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;time&lt;/span&gt; ./a.out 1 &amp;lt;in&amp;gt;out
real    2m46.823s
user    0m7.768s
sys     2m38.034s
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;结果可以看到，实际用时超过了2分钟，其中系统调用占用了绝大多数时间。&lt;/p&gt;
&lt;p&gt;再选择buf大小为8192：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;lijsf@echolii-PC:chapt3&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;time&lt;/span&gt; ./a.out 8192 &amp;lt;in&amp;gt;out
real    0m0.566s
user    0m0.000s
sys     0m0.152s
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;结果显示效率相对于上次的结果要好的多，原因时，此时系统调用的数目是上一次的4096分之一。实际上
由于block大小是4096,每一次系统调用只能读写4096字节，本次实验中虽然名面上每次读写了8192字节，
实际上系统会分两次读写，每次依然读写4096字节。&lt;/p&gt;
&lt;p&gt;最后选择每次读写4096字节，即理论上的最优大小。&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;lijsf@echolii-PC:chapt3&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;time&lt;/span&gt; ./a.out 4096 &amp;lt;in&amp;gt;out
real    0m0.131s
user    0m0.000s
sys     0m0.128s
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;对比上述8192的结果，可以看到，系统调用的时间并未有大的变化，但程序执行的实际时间却有更大的优化。
原因是，在选择了8192字节的buf时，系统不能一次读写完整个buf，所以需要花费时间等待系统IO完成的中
断。这会导致系统挂起执行线程，去执行其他的线程。所以程序的系统运行时间并未增加，但实际运行时间却
增加了。&lt;/p&gt;
&lt;p&gt;综上所述，在采用系统IO函数时，需要注意IO的效率，考虑合适的读写缓存buf，从而可以明显的改善程序的
在IO上的运行效率。&lt;/p&gt;</summary><category term="unix环境高级编程"></category><category term="linux编程"></category></entry><entry><title>mplayer字幕诸问题</title><link href="http://bluedream.me/mplayerzi-mu-zhu-wen-ti.html" rel="alternate"></link><updated>2013-03-02T22:23:00+08:00</updated><author><name>lijsf</name></author><id>tag:bluedream.me,2013-03-02:mplayerzi-mu-zhu-wen-ti.html</id><summary type="html">&lt;p&gt;mplayer功能强大，是linux下播放视频，电影的不二选择，但源于其功能太过于强大，
使用起来还是有很大的难度的，但归结到我这样的新手，英语又差的，最棘手的无疑
时字幕的诸多问题。本文记录我在使用mplayer时解决字幕问题的一些方法。&lt;/p&gt;
&lt;h2&gt;字幕下载&lt;/h2&gt;
&lt;p&gt;自己动手下载字幕是最简单的解决方法，但大多数时候由于影片的发布，压缩格式等
的不同，字幕的时序也不一样，这造成下载下来的外挂字幕大多不能和影片同步。&lt;/p&gt;
&lt;p&gt;win下有个splayer（射手播放器）很好用，可以自动跟据影片匹配射手网上的字幕，
并且自动下载加载播放，很实用的功能。splayer虽然开源，但遗憾的是其调用了大
量的windows API，换言之，即不能跨平台。所以在linux下还是得用mplayer系列播
放器。&lt;/p&gt;
&lt;p&gt;借助于脚本语言实现类似于splayer的功能是可行的，这方面，可以考虑的方法很多。
射手虽然没有提供开放的API，但这难不倒程序员，况且我们只是自己下载来看的，
并不做批量下载，所以避开射手的防机器人手段还是可以做到的。有了想法自然时
动手实现。上github搜了一下是否已经有高手实现过了。果然，已经有人实现了这么
一个脚本。这就是mplayer-wraper。作者的github的id是sunbing81，这是其项目主页
地址:http://gosubi.me/adow/mplayerwrapper，有很详细的介绍，照做不难。该项目有
bash和python两个版本，python实现了影片hash和字幕的hash匹配，可以很精准的
查找到字幕，基本不存在字幕时序问题。&lt;/p&gt;
&lt;h2&gt;字幕加载&lt;/h2&gt;
&lt;p&gt;通过mplayer-wraper可以下载到字幕，但mplayer加载字幕依然会出现问题。往往字幕
好好的，加载上去却时乱码。据我的观察，主要有两种乱码，其一是完全的乱码，其
二是字幕变成了下划线。&lt;/p&gt;
&lt;p&gt;前者完全乱码的原因是字幕编码的问题，只需在播放影片时指明字幕的编码，如下：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;mplayer -sub sub-file -subcp utf8 film-file
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这样一般是可以解决问题了，但有时虽不再是乱码，但却成了下划线。这是字体的问
题，mplayer需要指明字幕的字体才能正常显示。具体命令如下：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;mplayer -sub sub-file -subcp utf8 -font simhei film-file
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;simhei是一种中文linux下的字体，如果没有可以安装，或者使用现有的字体。可以在
/usr/share/fonts目录下找到系统安装的所有字体。&lt;/p&gt;
&lt;h2&gt;简单方法&lt;/h2&gt;
&lt;p&gt;上述方法可以实现目的，但看个电影敲一堆命令的体验肯定不好，有时再折腾半个小
时就更难受了。mplayer是一个成功的软件，自然可以写配置文件，有配置文件，所有
的命令行参数都可以写进去做为默认参数执行。&lt;/p&gt;
&lt;p&gt;如上文所示的命令，只需要在~/.mplayer/config文件里写上两行即可:&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;&lt;span class="nv"&gt;subcp&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;utf8&amp;#39;&lt;/span&gt;
&lt;span class="nv"&gt;font&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;simhei&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;如此即可直接用mplayer播放影片了，不需要再加其他参数，当然若遇上其他编码格式
的字幕文件，直接用默认参数肯定会乱码，可以在播放之前把字幕文件编码转为utf8，
或者在命令行里加上指明字幕编码的命令参数。&lt;/p&gt;</summary><category term="linux应用"></category><category term="mplayer"></category></entry><entry><title>ubuntu12.04 64位系统安装校园网客户端inodeClient</title><link href="http://bluedream.me/inodeClient_install.html" rel="alternate"></link><updated>2013-01-12T10:20:00+08:00</updated><author><name>lijsf</name></author><id>tag:bluedream.me,2013-01-12:inodeClient_install.html</id><summary type="html">&lt;h1&gt;主要步骤&lt;/h1&gt;
&lt;p&gt;(1).  下载安装包,解压到相应目录。&lt;/p&gt;
&lt;p&gt;(2).  64位系统，需要先安装32位的运行库：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;apt-get install ia32-libs* getlibs
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;若源中找不到getlibs库，可去http://forum.ubuntu.org.cn/viewtopic.php?t=205525下载deb包安装。&lt;/p&gt;
&lt;p&gt;(3).  进入inodeClient目录，修改iNodeCLient根目录下的enablecards.ps。将其中第二行cd /etc/sysconfig/network-scripts
 修改为cd /etc/network,再运行install.sh。注意install.sh的权限。&lt;/p&gt;
&lt;p&gt;(4).  安装后可通过 &lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;ps -e|grep A
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;命令查看是否安装成功，结果类似于：1694 ?        00:00:00 AuthenMngServic
表示安装成功。若无该服务进程，则安装不成功。&lt;/p&gt;
&lt;p&gt;(5). 安装后， 若运行不成功，多会提示缺少libtiff.so.3和libjpeg.so.62两个库文件，32位的系统可以直接通过下面的命令建立软链接：&lt;/p&gt;
&lt;div class="codehilite"&gt;&lt;pre&gt;ln -s /usr/lib/libtiff.so.3 /usr/lib/i386-linux-gnu/libtiff.so.4.x. x
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;libjpeg.so.62也可类似处理。若找不到对应的较新的库的位置，可用命令locate libtiff.so查找其位置。&lt;/p&gt;
&lt;p&gt;(6).  对64位系统，在处理litfiff或者libjpeg库时可能建立软链接后因为库inode不识别64位的libtiff和libjpeg而不能运行。可以去
 微盘下载这两个文件，放到/usr/lib目录下即可。&lt;/p&gt;</summary><category term="ubuntu12.04"></category><category term="inodeClient"></category><category term="linux应用"></category><category term="校园网"></category></entry></feed>